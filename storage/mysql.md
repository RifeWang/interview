# MySQL

参考云服务提供商的[性能数据](https://cloud.tencent.com/document/product/236/68814)。

一般 TPS 在几千，QPS 能达到几万甚至十万以上，QPS 是 TPS 的大约 20 倍，例如：
- MySQL 5.7 / 8C32G
    - TPS: 3895
    - QPS: 77904
- PostgreSQL / 8C32G
    - TPS: 4037
    - QPS: 80741

## 限制

实例 -> 数据库 -> 表 -> 列/行

- 每个数据库对应一个目录，MySQL 对数据库的数量没有硬性限制，取决于文件系统对子目录数量的限制。
- 每个表对应多个文件（例如 .frm 和 .ibd 文件），MySQL 对表的数量也没有硬性限制。
- 一个表最多可以有 4096 列，但实际与行的限制也密切相关。
- 每行数据大小限制为 `65535` 字节，这个限制包括所有列的数据、行开销以及 BLOB/TEXT 列的前缀存储（ BLOB/TEXT 列的实际数据存储在单独的`溢出页`中，如果单行数据超出了 page 大小也会被存储到溢出页中）。

## 事务

事务：多个操作要么全部成功，要么全部失败。

事务的特点 ACID :
- A : `atomicity`   原子性
- C : `consistency` 一致性
- I : `isolation`   隔离性
- D : `durability`  持久性

并发控制、日志恢复


- 事务的原子性是通过 `undo log` 来实现
- 事务的持久性是通过 `redo log` 来实现
- 事务的隔离性是通过 `读写锁 + MVCC` 来实现
- 事务的一致性是通过 `原子性、持久性、隔离性` 来实现


- `undo log`: 是逻辑日志，可以理解为记录当前操作的相反操作。
- `redo log`: 记录的是新数据的备份。在事务提交前，只要将 redo log 持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是可以根据 redo log 的内容将数据恢复到最新的状态。


数据写入 > buffer > fsync 刷盘


事务的隔离级别：
- `READ UNCOMMITTED` 读未提交，对事务处理的读取没有任何限制，不推荐。 问题：`脏读、不可重复读、幻读`
- `READ COMMITTED`   读已提交。 问题：`不可重复读、幻读`
- `REPEATABLE READ`  可重复读。 问题：`幻读`
- `SERIALIZABLE`     串行化

事务问题：
- `脏读`: 读取到未提交的数据
- `不可重复读`: 同一个事务中两次读取的数据不一致
- `幻读`: 在同一个事务里，select 的结果是事务开始时时间点的状态，因此，同样的 select 操作读到的结果会是一致的，但是，会有幻读现象。MySQL 的 InnoDB 引擎可以通过 next-key locks 机制（参考"行锁的算法"）来避免幻读。幻读应该是事务对另外事务的插入操作没有隔离，导致了同一个事务里面同样的查询条件出现不同条数的查询结果。


锁：
- `共享锁` ：其他事务只能查询
- `排他锁` ：


## 三星索引

三星索引的概念来源于《数据库索引设计与优化》。

- 如果与一个查询相关的索引行是相邻的，或者至少相距足够靠近的话，就可以标上第一颗星，这是最小化了必须扫描的索引片的宽度
- 如果索引行的顺序与查询语句的需求一致，可以标记为第二颗星，这排除了排序操作
- 如果索引行包含查询语句中的所有列，可以标记为第三颗星，避免了访问表的操作，仅访问索引就可以了

优点：
- 减少查询需要扫描的数据量(加快了查询速度)
- 减少服务器的排序操作和创建临时表的操作(加快了groupby和orderby等操作)
- 将服务器的随机IO变为顺序IO(加快查询速度)

简单的记为：
- where 条件命中索引
- order by 命中索引
- select 列命中索引

## InnoDB: B+ tree 、聚簇（cu）索引

B+ Tree vs B Tree:
- B+ Tree 只在叶子节点存储数据，B Tree 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I/O 次数下，就能查询更多的节点。
- B+ Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。

B+ tree: 只有叶子结点存储数据 value ，其他结点只存储索引 key

- 主键索引（聚簇索引）：叶子节点存放的是实际数据
- 二级索引（辅助索引）：叶子节点存放的是主键值

InnoDB 会以主键+数据构建聚簇索引，辅助索引构建非主键索引（索引+主键），通过辅助索引查数据一般是先找到主键，再通过主键回表。


InnoDB 默认每个 page 16 KB，对于 B+ Tree，每个节点都是一个 page，根节点 16 KB，假设主键使用自增 INT 占用 4 B、其它大小为 12 B，那么根节点可以指向 1 K 个下级节点，第二级节点可以指向 1 M 个子节点，第三级节点可以指向 1 B 个子节点，所以一般 B+ Tree 的高度为 3 ~ 4 层就够用了。

实际树的高度取决于每行数据占用的大小，假设 page 16 KB，15 KB 用来存放数据，每行数据占用 1 KB，那么每个 page 可以存储 15 行，快速估算的话二层树大概能存 15K 行，三层树大概 15M 行数据（实际情况根节点不止 1K，往往经验上说单表 2 千万行数据就是这么来的）。


## 参考文章

- https://xiaolincoding.com/mysql/base/row_format.html