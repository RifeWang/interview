# 设计模式

设计模式是软件工程中的一种通用解决方案，用于解决特定的设计问题。这些模式是一种被广泛接受的、可重用的设计方案，能够帮助开发人员创建灵活、可扩展和可维护的软件系统。

设计模式主要分为三大类：
- 创建型模式：提供了创建对象的机制，能够提升已有代码的灵活性和可复用性。
- 结构型模式：介绍如何将对象和类组装成较大的结构，并同时保持结构的灵活和高效。
- 行为型模式：负责对象间的高效沟通和职责委派。

## 创建型模式

- 工厂方法 `Factory Method`：在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。
    - 适用场景：无法预知对象确切类别及其依赖关系。
    - 优点：避免创建者和具体产品之间的紧密耦合。
    - 缺点：引入许多新的子类，代码可能会变得更复杂。

- 抽象工厂 `Abstract Factory`：创建一系列相关的对象，而无需指定其具体类（一般应用程序会在初始化阶段创建具体工厂对象）。
    - 适用场景：代码需要与多个不同系列的相关产品交互，但是由于无法提前获取相关信息，或者出于对未来扩展性的考虑，你不希望代码基于产品的具体类进行构建，在这种情况下可以使用抽象工厂。
    - 优点：确保同一工厂生产的产品相互匹配，避免客户端和具体产品代码的耦合。
    - 缺点：需要向应用中引入众多接口和类，代码可能会比之前更加复杂。

- 生成器 `Builder`：分步骤创建复杂对象。该模式允许你使用相同的创建代码生成不同类型和形式的对象。
    - 适用场景：避免多种构造函数。
    - 优点：分步骤创建对象，支持方法链。
    - 缺点：需要新增多个类，因此代码整体复杂程度会有所增加。

- 原型 `Prototype`：能够复制已有对象，而又无需使代码依赖它们所属的类。
    - 适用场景：需要复制一些对象，同时又希望代码独立于这些对象所属的具体类。
    - 优点：可以克隆对象而无需与它们所属的具体类相耦合，同时避免反复运行初始化代码。
    - 缺点：克隆包含循环引用的复杂对象可能会非常麻烦。

- 单例 `Singleton`：保证一个类只有一个实例，并提供一个访问该实例的全局节点。
    - 适用场景：严格地控制全局变量或共享资源如数据库连接。
    - 优点：保证一个类只有一个实例，仅在首次请求时进行初始化。
    - 缺点：在多线程环境下需要进行特殊处理，避免多个线程多次创建单例对象。单例拥有与全局变量相同的优缺点，许多开发者将单例模式视为一种反模式。

## 结构型模式

- 适配器 `Adapter`
- 桥接 `Bridge`
- 组合 `Composite`
- 装饰 `Decorator`
- 外观 `Facade`
- 享元 `Flyweight`
- 代理 `Proxy`

## 行为模式

- 责任链 `Chain of Responsibility`
- 命令 `Command`
- 迭代器 `Iterator`
- 中介者 `Mediator`
- 备忘录 `Memento`
- 观察者 `Observer`
- 状态 `State`
- 策略 `Strategy`
- 模板方法 `Template Method`
- 访问者 `Visitor`



## 参考资料

- https://refactoringguru.cn/design-patterns