# 设计模式

设计模式是软件工程中的一种通用解决方案，用于解决特定的设计问题。这些模式是一种被广泛接受的、可重用的设计方案，能够帮助开发人员创建灵活、可扩展和可维护的软件系统。

设计模式主要分为三大类：
- 创建型模式：提供了创建对象的机制，能够提升已有代码的灵活性和可复用性。
- 结构型模式：介绍如何将对象和类组装成较大的结构，并同时保持结构的灵活和高效。
- 行为型模式：负责对象间的高效沟通和职责委派。

## 创建型模式

- 工厂方法 `Factory Method`：在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。
    - 场景：无法预知对象确切类别及其依赖关系。
    - 优点：避免创建者和具体产品之间的紧密耦合。
    - 缺点：引入许多新的子类，代码可能会变得更复杂。

- 抽象工厂 `Abstract Factory`：创建一系列相关的对象，而无需指定其具体类（一般应用程序会在初始化阶段创建具体工厂对象）。
    - 场景：代码需要与多个不同系列的相关产品交互，但是由于无法提前获取相关信息，或者出于对未来扩展性的考虑，你不希望代码基于产品的具体类进行构建，在这种情况下可以使用抽象工厂。
    - 优点：确保同一工厂生产的产品相互匹配，避免客户端和具体产品代码的耦合。
    - 缺点：需要向应用中引入众多接口和类，代码可能会比之前更加复杂。

- 生成器 `Builder`：分步骤创建复杂对象。该模式允许你使用相同的创建代码生成不同类型和形式的对象。
    - 场景：避免多种构造函数。
    - 优点：分步骤创建对象，支持方法链。
    - 缺点：需要新增多个类，因此代码整体复杂程度会有所增加。

- 原型 `Prototype`：能够复制已有对象，而又无需使代码依赖它们所属的类。
    - 场景：需要复制一些对象，同时又希望代码独立于这些对象所属的具体类。
    - 优点：可以克隆对象而无需与它们所属的具体类相耦合，同时避免反复运行初始化代码。
    - 缺点：克隆包含循环引用的复杂对象可能会非常麻烦。

- 单例 `Singleton`：保证一个类只有一个实例，并提供一个访问该实例的全局节点。
    - 场景：严格地控制全局变量或共享资源如数据库连接。
    - 优点：保证一个类只有一个实例，仅在首次请求时进行初始化。
    - 缺点：在多线程环境下需要进行特殊处理，避免多个线程多次创建单例对象。单例拥有与全局变量相同的优缺点，许多开发者将单例模式视为一种反模式。

## 结构型模式

- 适配器 `Adapter`：使接口不兼容的对象能够相互合作。
    - 场景：通常在已有程序中使用，让相互不兼容的类能很好地合作。
    - 优点：只要客户端代码通过客户端接口与适配器进行交互，你就能在不修改现有客户端代码的情况下在程序中添加新类型的适配器。
    - 缺点：代码整体复杂度增加，因为你需要新增一系列接口和类。有时直接更改服务类使其与其他代码兼容会更简单。

- 桥接 `Bridge`：将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构，从而能在开发时分别使用。
    - 场景：想要拆分或重组一个具有多重功能的庞杂类；希望在几个独立维度上扩展一个类。
    - 优点：客户端代码仅与高层抽象部分进行互动，不会接触到平台的详细信息。
    - 缺点：对高内聚的类使用该模式可能会让代码更加复杂。
    - 桥接模式通常会于开发前期进行设计，使你能够将程序的各个部分独立开来以便开发。适配器模式通常在已有程序中使用，让相互不兼容的类能很好地合作。

- 组合 `Composite`：将对象组合成树状结构，并且能像使用独立对象一样使用它们。
    - 场景：需要实现树状对象结构。
    - 优点：可以利用多态和递归机制更方便地使用复杂树结构。
    - 缺点：对于功能差异较大的类，提供公共接口或许会有困难。在特定情况下，你需要过度一般化组件接口，使其变得令人难以理解。

- 装饰 `Decorator`：通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。
    - 场景：希望在无需修改代码的情况下即可使用对象，且希望在运行时为对象新增额外的行为。
    - 优点：无需创建新子类即可扩展对象的行为。可以用多个装饰封装对象来组合几种行为。
    - 缺点：在封装器栈中删除特定封装器比较困难。实现行为不受装饰栈顺序影响的装饰比较困难。

- 外观 `Facade`：能为程序库、框架或其他复杂类提供一个简单的接口。
    - 场景：需要一个指向复杂子系统的直接接口，且该接口的功能有限。
    - 优点：可以让自己的代码独立于复杂子系统。
    - 缺点：外观可能成为与程序中所有类都耦合的上帝对象。

- 享元 `Flyweight`：摒弃了在每个对象中保存所有数据的方式，通过共享多个对象所共有的相同状态，让你能在有限的内存容量中载入更多对象。
    - 场景：仅在程序必须支持大量对象且没有足够的内存容量时使用享元模式。
    - 优点：如果程序中有很多相似对象可以节省大量内存。
    - 缺点：可能需要牺牲执行速度来换取内存，因为他人每次调用享元方法时都需要重新计算部分情景数据。代码会变得更加复杂，需要拆分一个实体的状态。

- 代理 `Proxy`：提供对象的替代品或其占位符。代理控制着对于原对象的访问，并允许在将请求提交给对象前后进行一些处理。
    - 场景：多种多样。
    - 优点：可以在客户端毫无察觉的情况下控制服务对象。
    - 缺点：代码可能会变得复杂，因为需要新建许多类。服务响应可能会延迟。


## 行为模式

- 责任链 `Chain of Responsibility`：将请求沿着处理者链进行发送。收到请求后，每个处理者均可对请求进行处理，或将其传递给链上的下个处理者。

- 命令 `Command`：将请求转换为一个包含与请求相关的所有信息的独立对象。该转换让你能根据不同的请求将方法参数化、延迟请求执行或将其放入队列中，且能实现可撤销操作。

- 迭代器 `Iterator`：在不暴露集合底层表现形式（列表、 栈和树等）的情况下遍历集合中所有的元素。

- 中介者 `Mediator`：限制对象之间的直接交互，迫使它们通过一个中介者对象进行合作。

- 备忘录 `Memento`：在不暴露对象实现细节的情况下保存和恢复对象之前的状态。

- 观察者 `Observer`：定义一种订阅机制，可在对象事件发生时通知多个观察该对象的其他对象。

- 状态 `State`：能在一个对象的内部状态变化时改变其行为，使其看上去就像改变了自身所属的类一样。

- 策略 `Strategy`：定义一系列算法，并将每种算法分别放入独立的类中，以使算法的对象能够相互替换。

- 模板方法 `Template Method`：在超类中定义了一个算法的框架，允许子类在不修改结构的情况下重写算法的特定步骤。

- 访问者 `Visitor`：将算法与其所作用的对象隔离开来。



## 参考资料

- https://refactoringguru.cn/design-patterns